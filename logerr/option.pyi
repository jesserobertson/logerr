"""Type stubs for logerr.option module."""

from __future__ import annotations

from abc import ABC, abstractmethod
from collections.abc import Callable
from typing import TypeVar

T = TypeVar("T")
U = TypeVar("U")

class Option[T](ABC):
    """Abstract base class for Option types."""

    @abstractmethod
    def is_some(self) -> bool:
        """Check if this Option contains a value."""
        ...

    @abstractmethod
    def is_nothing(self) -> bool:
        """Check if this Option contains no value."""
        ...

    @abstractmethod
    def unwrap(self) -> T:
        """Extract the contained value, raising an exception if this is Nothing."""
        ...

    @abstractmethod
    def unwrap_or(self, default: T) -> T:
        """Extract the contained value or return a default."""
        ...

    @abstractmethod
    def unwrap_or_else(self, f: Callable[[], T]) -> T:
        """Extract the contained value or compute one from a closure."""
        ...

    @abstractmethod
    def map[U](self, f: Callable[[T], U]) -> Option[U]:
        """Transform the contained value if present."""
        ...

    @abstractmethod
    def then[U](self, f: Callable[[T], Option[U]]) -> Option[U]:
        """Chain Option-returning operations (also known as flatmap)."""
        ...

    @abstractmethod
    def or_else(self, f: Callable[[], Option[T]]) -> Option[T]:
        """Chain Option-returning operations on the Nothing case."""
        ...

    @abstractmethod
    def or_default(self, default: T) -> Option[T]:
        """Return Some(default) if this is Nothing, otherwise return this Some."""
        ...

    @abstractmethod
    def filter(self, predicate: Callable[[T], bool]) -> Option[T]:
        """Keep the value only if it satisfies a predicate."""
        ...

    @classmethod
    def from_nullable(cls, value: T | None) -> Option[T]:
        """Create an Option from a potentially None value."""
        ...

    @classmethod
    def of(cls, f: Callable[[], T | None]) -> Option[T]:
        """Create an Option from a callable that might return None."""
        ...

    @classmethod
    def from_predicate(
        cls,
        value: T,
        predicate: Callable[[T], bool],
        *,
        error_message: str | None = None,
    ) -> Option[T]:
        """Create an Option based on whether a predicate is satisfied."""
        ...

class Some[T](Option[T]):
    """Represents an option containing a value."""

    __match_args__: tuple[str, ...]
    _value: T

    def __init__(self, value: T) -> None:
        """Initialize a Some option with a value."""
        ...

    def is_some(self) -> bool: ...
    def is_nothing(self) -> bool: ...
    def unwrap(self) -> T: ...
    def unwrap_or(self, default: T) -> T: ...
    def unwrap_or_else(self, f: Callable[[], T]) -> T: ...
    def map[U](self, f: Callable[[T], U]) -> Option[U]: ...
    def then[U](self, f: Callable[[T], Option[U]]) -> Option[U]: ...
    def or_else(self, f: Callable[[], Option[T]]) -> Option[T]: ...
    def or_default(self, default: T) -> Option[T]: ...
    def filter(self, predicate: Callable[[T], bool]) -> Option[T]: ...
    def __repr__(self) -> str: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __le__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...

class Nothing[T](Option[T]):
    """Represents an option with no value."""

    __match_args__: tuple[str, ...]
    _reason: str

    def __init__(
        self, reason: str = "No value", *, _skip_logging: bool = False
    ) -> None:
        """Initialize a Nothing option with a reason."""
        ...

    def _log_nothing(self) -> None:
        """Log the Nothing case using configured logging settings."""
        ...

    @classmethod
    def from_exception(cls, exception: Exception) -> Nothing[T]:
        """Create a Nothing from an exception with automatic logging."""
        ...

    @classmethod
    def from_none(cls, reason: str = "Value was None") -> Nothing[T]:
        """Create a Nothing from a None value with automatic logging."""
        ...

    @classmethod
    def from_filter(cls, reason: str = "Filter condition failed") -> Nothing[T]:
        """Create a Nothing from a failed filter predicate with automatic logging."""
        ...

    @classmethod
    def empty(cls) -> Nothing[T]:
        """Create a Nothing without logging (for normal control flow)."""
        ...

    def is_some(self) -> bool: ...
    def is_nothing(self) -> bool: ...
    def unwrap(self) -> T: ...
    def unwrap_or(self, default: T) -> T: ...
    def unwrap_or_else(self, f: Callable[[], T]) -> T: ...
    def map[U](self, f: Callable[[T], U]) -> Option[U]: ...
    def then[U](self, f: Callable[[T], Option[U]]) -> Option[U]: ...
    def or_else(self, f: Callable[[], Option[T]]) -> Option[T]: ...
    def or_default(self, default: T) -> Option[T]: ...
    def filter(self, predicate: Callable[[T], bool]) -> Option[T]: ...
    def __repr__(self) -> str: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __le__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...

def of[T](f: Callable[[], T | None]) -> Option[T]:
    """Execute a callable and return Some(result) or Nothing."""
    ...

def from_nullable[T](value: T | None) -> Option[T]:
    """Convert a nullable value to an Option."""
    ...

def from_predicate(
    value: T, predicate: Callable[[T], bool], *, error_message: str | None = None
) -> Option[T]:
    """Create an Option based on whether a value satisfies a predicate."""
    ...

def predicate_filter[T](
    predicate: Callable[[T], bool], *, error_message: str | None = None
) -> Callable[[T], Option[T]]:
    """Create a reusable predicate filter function."""
    ...
