"""Type stubs for logerr.result module."""

from __future__ import annotations

from abc import ABC, abstractmethod
from collections.abc import Callable
from typing import Any, TypeVar

T = TypeVar("T")
E = TypeVar("E")
U = TypeVar("U")

class Result[T, E](ABC):
    """Abstract base class for Result types."""

    @abstractmethod
    def is_ok(self) -> bool:
        """Check if this Result contains a success value."""
        ...

    @abstractmethod
    def is_err(self) -> bool:
        """Check if this Result contains an error value."""
        ...

    @abstractmethod
    def unwrap(self) -> T:
        """Extract the success value, raising an exception if this is an Err."""
        ...

    @abstractmethod
    def unwrap_or(self, default: T) -> T:
        """Extract the success value or return a default."""
        ...

    @abstractmethod
    def unwrap_or_else(self, f: Callable[[E], T]) -> T:
        """Extract the success value or compute one from the error."""
        ...

    @abstractmethod
    def map[U](self, f: Callable[[T], U]) -> Result[U, E]:
        """Transform the success value if present."""
        ...

    @abstractmethod
    def map_err[U](self, f: Callable[[E], U]) -> Result[T, U]:
        """Transform the error value if present."""
        ...

    @abstractmethod
    def then[U](self, f: Callable[[T], Result[U, E]]) -> Result[U, E]:
        """Chain Result-returning operations (also known as flatmap)."""
        ...

    @abstractmethod
    def or_else[U](self, f: Callable[[E], Result[T, U]]) -> Result[T, U]:
        """Chain Result-returning operations on the error case."""
        ...

    @classmethod
    def of(cls, f: Callable[[], T]) -> Result[T, Exception]:
        """Create a Result from a callable that might raise an exception."""
        ...

    @classmethod
    def from_optional(cls, value: T | None, error: E) -> Result[T, E]:
        """Create a Result from an optional value."""
        ...

    @classmethod
    def from_predicate(
        cls, value: T, predicate: Callable[[T], bool], error: E
    ) -> Result[T, E]:
        """Create a Result based on whether a predicate is satisfied."""
        ...

class Ok[T, E](Result[T, E]):
    """Represents a successful result containing a value."""

    __match_args__: tuple[str, ...]
    _value: T

    def __init__(self, value: T) -> None:
        """Initialize an Ok result with a value."""
        ...

    def is_ok(self) -> bool: ...
    def is_err(self) -> bool: ...
    def unwrap(self) -> T: ...
    def unwrap_or(self, default: T) -> T: ...
    def unwrap_err(self) -> E: ...
    def unwrap_or_else(self, f: Callable[[E], T]) -> T: ...
    def map[U](self, f: Callable[[T], U]) -> Result[U, E]: ...
    def map_err[U](self, f: Callable[[E], U]) -> Result[T, U]: ...
    def then[U](self, f: Callable[[T], Result[U, E]]) -> Result[U, E]: ...
    def or_else[U](self, f: Callable[[E], Result[T, U]]) -> Result[T, U]: ...
    def __repr__(self) -> str: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __le__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...

class Err[T, E](Result[T, E]):
    """Represents a failed result containing an error."""

    __match_args__: tuple[str, ...]
    _error: E

    def __init__(self, error: E, *, _skip_logging: bool = False) -> None:
        """Initialize an Err result with an error value."""
        ...

    def _log_error(self) -> None:
        """Log the error using configured logging settings."""
        ...

    @classmethod
    def from_exception(cls, exception: Exception) -> Err[Any, Exception]:
        """Create an Err from an exception with automatic logging."""
        ...

    @classmethod
    def from_value(cls, error: E) -> Err[T, E]:
        """Create an Err from any error value with automatic logging."""
        ...

    def is_ok(self) -> bool: ...
    def is_err(self) -> bool: ...
    def unwrap(self) -> T: ...
    def unwrap_err(self) -> E: ...
    def unwrap_or(self, default: T) -> T: ...
    def unwrap_or_else(self, f: Callable[[E], T]) -> T: ...
    def map[U](self, f: Callable[[T], U]) -> Result[U, E]: ...
    def map_err[U](self, f: Callable[[E], U]) -> Result[T, U]: ...
    def then[U](self, f: Callable[[T], Result[U, E]]) -> Result[U, E]: ...
    def or_else[U](self, f: Callable[[E], Result[T, U]]) -> Result[T, U]: ...
    def __repr__(self) -> str: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __le__(self, other: object) -> bool: ...
    def __gt__(self, other: object) -> bool: ...
    def __ge__(self, other: object) -> bool: ...

def of[T](f: Callable[[], T]) -> Result[T, Exception]:
    """Execute a callable and return Ok(result) or Err(exception)."""
    ...

def from_optional[T, E](value: T | None, error: E) -> Result[T, E]:
    """Convert an Optional value to a Result."""
    ...

def from_predicate(value: T, predicate: Callable[[T], bool], error: E) -> Result[T, E]:
    """Create a Result based on whether a value satisfies a predicate."""
    ...

def predicate_validator[T, E](
    predicate: Callable[[T], bool], error: E
) -> Callable[[T], Result[T, E]]:
    """Create a reusable predicate validator function."""
    ...
